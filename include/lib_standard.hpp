#include <string>
using namespace std;


string lib_s = "get_compute_mode()[]{ push 2 0; push 3 10; 0 + -> mode; push 2 mode; push 3 10; return mode; };set_compute_mode(mode)[none]{ push 2 mode; push 3 10;};check_compute_mode(check)[none]{ !get_compute_mode() -> mode; !set_compute_mode(0); if (mode check =){ !set_compute_mode(mode); return true; } else { !set_compute_mode(mode); return false; };};set_stack_garbage_collection(mode)[none]{ push 2 mode; push 3 11;};time()[none]{ !get_compute_mode() -> mode; !set_compute_mode(0); push 3 Sys_time; 0 + -> t; !set_compute_mode(mode); return t;};and(val1, val2)[false, false]{ !typecheck(val1, \"bool\", \"!and\"); !typecheck(val2, \"bool\", \"!and\"); if (val1){ if (val2){ return true; } else { return false; }; } else { return false; };};or(val1, val2)[false, false]{ !typecheck(val1, \"bool\", \"!or\"); !typecheck(val2, \"bool\", \"!or\"); if (val1){ return true; }; if (val2){ return true; }; return false;};xor(val1, val2)[false, false]{ !typecheck(val1, \"bool\", \"!xor\"); !typecheck(val2, \"bool\", \"!xor\"); if (val1){ if (val2){ return false; }; return true; }; if (val2){ if (val1){ return false; }; return true; }; return false;};in(val1, val2)[false, false]{ !get_compute_mode() -> mode; !set_compute_mode(0); !typecheck(val2, \"list\", \"!in\"); for(i, 0, !len(val2)){ if(val2 i * val1 =) { !set_compute_mode(mode); return true; }; }; !set_compute_mode(mode); return false;};not(val1)[false]{ !typecheck(val1, \"bool\", \"!xor\"); if(val1) { return false; }; return true;};sleep(value)[none]{ push 2 value; push 3 4;};max_between(x, y)[none, none]{ !get_compute_mode() -> mode; !set_compute_mode(0); if (x y >){ return x; }; !set_compute_mode(mode); return y;};typeof(variable)[none]{ !get_compute_mode() -> mode; !set_compute_mode(0); type variable; \"\" + -> typef; !set_compute_mode(mode); return typef;};sum_between(x, y)[none]{ !get_compute_mode() -> mode; !set_compute_mode(0); !typecheck(x, \"int\", \"!sum\"); !typecheck(y, \"int\", \"!sum\"); !assert(x y <, \"the second argument should be greater than the first\", \"!sum_between\"); 0 -> total; for(i, x, y){ total i + -> total; }; !set_compute_mode(mode); return total;};struct map { [] -> keys; [] -> values; add(self, key, value)[none] { self.keys + key; self.values + value; }; get(self, key)[none] { length self.values; + 0 -> len; for(i, 0, len) { if(self.keys*i = key) { return self.values * i; }; }; }; in(self, key)[none] { length self.values; + 0 -> len; for(i, 0, len) { if(self.keys*i = key) { return true; }; }; return false; }; print(self)[none] { length self.values; + 0 -> len; for(i, 0, len) { self.keys*i -> k; self.values*i -> v; push 1 \" { \"; push 1 k; push 1 \" : \"; push 1 v; push 1 \" }\"; }; push 1 \" \\n\"; }; to_string(self)[none] { \"\" -> str; length self.values; + 0 -> len; for(i, 0, len) { self.keys*i -> k; self.values*i -> v; str + \" { \" -> str; str + k -> str; str + \" : \" -> str; str + v -> str; str + \" }\" -> str; }; return str; };};print(value)[none]{ push 1 value; push 1 \"\\n\";};input(value)[none]{ !get_compute_mode() -> mode; !set_compute_mode(0); push 1 value; push 3 5; \"\" + -> result; !set_compute_mode(mode); return result;};open(file)[none]{ !get_compute_mode() -> mode; !set_compute_mode(0); push system 8; \"\" + -> dir; push computeStack dir file +; push system Sys_openFile; \"\" + -> res; !set_compute_mode(mode); return res;};operator \"or\" \"!or\";operator \"and\" \"!and\";operator \"xor\" \"!xor\";operator \"in\" \"!in\"; typecheck(a, b, c)[none]{};len(list)[none]{!get_compute_mode() -> mode;!set_compute_mode(0);!typecheck(list, \"list\", \"!len\");length list;0 + -> total;!set_compute_mode(mode);return total;};";